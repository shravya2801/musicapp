{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\project\\\\MusicAppMERN-master\\\\MusicAppMERN-master\\\\Music\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\project\\\\MusicAppMERN-master\\\\MusicAppMERN-master\\\\Music\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _toConsumableArray from \"C:\\\\project\\\\MusicAppMERN-master\\\\MusicAppMERN-master\\\\Music\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"C:\\\\project\\\\MusicAppMERN-master\\\\MusicAppMERN-master\\\\Music\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport * as types from '../actions/action-types';\nimport skipUnavailableTracks from '../utils/skipUnavailableTracks';\n\nvar setToken = function setToken(token) {\n  return {\n    token,\n    type: types.TOKEN_SET\n  };\n};\n\nvar setGenres = function setGenres(genres) {\n  return {\n    genres,\n    type: types.GENRES_SET\n  };\n};\n\nvar setCategoryPlaylist = function setCategoryPlaylist(categoryPlaylist) {\n  return {\n    categoryPlaylist,\n    type: types.CATEGORY_PLAYLIST_SET\n  };\n};\n\nvar fetchWithToken = function fetchWithToken(url, token) {\n  return fetch(url, {\n    headers: new Headers({\n      Authorization: 'Bearer ' + token.access_token\n    })\n  }).then(function (res) {\n    return res.json();\n  });\n};\n\nexport var clearCategoryPlaylist = function clearCategoryPlaylist() {\n  return {\n    type: types.CATEGORY_PLAYLIST_CLEAR\n  };\n};\nexport var fetchToken = function fetchToken() {\n  return function (dispatch) {\n    return fetch('https://ndj7ih3fo8.execute-api.eu-central-1.amazonaws.com/LATEST/').then(function (res) {\n      return res.json();\n    }).then(function (token) {\n      return dispatch(setToken(token));\n    }) // tslint:disable-next-line\n    .catch(function (err) {\n      return console.log('Error fetching Token', err);\n    }); // TODO add error handling\n  };\n};\nexport var fetchFeatured = function fetchFeatured() {\n  return function (dispatch, getState) {\n    var _getState = getState(),\n        token = _getState.token;\n\n    var url = 'https://api.spotify.com/v1/browse/featured-playlists';\n    return fetchWithToken(url, token).then(function (data) {\n      if (data.error) {\n        throw data.error.message;\n      }\n\n      dispatch({\n        featured: data.playlists.items,\n        sectionMessage: data.message,\n        type: types.FEATURED_SET\n      });\n    }) // tslint:disable-next-line\n    .catch(function (err) {\n      return console.log('Error fetching Featured', err);\n    }); // TODO add error handling\n  };\n};\nexport var fetchGenres = function fetchGenres() {\n  return function (dispatch, getState) {\n    var _getState2 = getState(),\n        token = _getState2.token;\n\n    var url = 'https://api.spotify.com/v1/browse/categories?limit=50';\n    fetchWithToken(url, token).then(function (data) {\n      if (data.error) {\n        throw data.error.message;\n      }\n\n      dispatch(setGenres(data.categories.items));\n    }) // tslint:disable-next-line\n    .catch(function (err) {\n      return console.error(err);\n    });\n  };\n};\nexport var fetchCategoryPlaylist = function fetchCategoryPlaylist(categoryId) {\n  return function (dispatch, getState) {\n    var _getState3 = getState(),\n        token = _getState3.token;\n\n    var url = \"https://api.spotify.com/v1/browse/categories/\".concat(categoryId, \"/playlists?limit=50\");\n    fetchWithToken(url, token).then(function (data) {\n      if (data.error) {\n        throw data.error.message;\n      }\n\n      dispatch(setCategoryPlaylist(data.playlists.items));\n    }) // tslint:disable-next-line\n    .catch(function (err) {\n      return console.error(err);\n    });\n  };\n};\n\nvar setNewReleases = function setNewReleases(albums) {\n  return {\n    albums,\n    type: types.NEW_RELEASES_SET\n  };\n};\n\nexport var fetchNewReleases = function fetchNewReleases() {\n  return function (dispatch, getState) {\n    var _getState4 = getState(),\n        token = _getState4.token;\n\n    var url = 'https://api.spotify.com/v1/browse/new-releases?limit=50';\n    fetchWithToken(url, token).then(function (data) {\n      return dispatch(setNewReleases(data.albums.items));\n    });\n  };\n};\n\nvar normalizeTracks = function normalizeTracks(trackArray, images) {\n  return trackArray.map(function (track, i) {\n    return {\n      track: _objectSpread(_objectSpread({}, track), {}, {\n        album: {\n          images: _toConsumableArray(images)\n        }\n      })\n    };\n  });\n};\n\nexport var fetchPlaylistView = function fetchPlaylistView(href) {\n  return function (dispatch, getState) {\n    var _getState5 = getState(),\n        token = _getState5.token,\n        playlist = _getState5.playlist;\n\n    if (href === playlist.href) {\n      dispatch({\n        type: types.COPY_TO_VIEW\n      });\n    } else {\n      fetchWithToken(href, token).then(function (data) {\n        var tracks = data.type === 'album' ? normalizeTracks(data.tracks.items, data.images) : data.tracks.items;\n        dispatch({\n          playlist: {\n            description: data.description,\n            href,\n            imageUrl: data.images[0].url,\n            name: data.name,\n            owner: data.owner && data.owner.display_name,\n            type: data.type\n          },\n          tracks,\n          type: types.SET_PLAYLIST_VIEW\n        });\n      });\n    }\n  };\n}; // Fetches playlist if not in memory and starts it from first available track\n\nexport var startPlaylist = function startPlaylist(_ref) {\n  var href = _ref.href;\n  return /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(dispatch, getState) {\n      var _getState6, playlist, tracks, token, data, trackId;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _getState6 = getState(), playlist = _getState6.playlist, tracks = _getState6.tracklist, token = _getState6.token;\n              dispatch({\n                type: types.STOP_PLAY\n              });\n\n              if (!(href !== playlist.href)) {\n                _context.next = 10;\n                break;\n              }\n\n              _context.next = 5;\n              return fetchWithToken(href, token);\n\n            case 5:\n              data = _context.sent;\n\n              if (!data.error) {\n                _context.next = 8;\n                break;\n              }\n\n              throw data.error.message;\n\n            case 8:\n              playlist = {\n                description: data.description,\n                href,\n                imageUrl: data.images[0].url,\n                name: data.name,\n                owner: data.owner.display_name,\n                type: data.type\n              };\n              tracks = data.tracks.items;\n\n            case 10:\n              trackId = skipUnavailableTracks(tracks, 0);\n              dispatch({\n                playlist,\n                trackId,\n                tracks,\n                type: types.PLAYLIST_SET\n              });\n\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x, _x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n}; // Fetches album if not in memory and starts it from first available track\n\nexport var startAlbum = function startAlbum(_ref3) {\n  var href = _ref3.href;\n  return /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(dispatch, getState) {\n      var _getState7, playlist, token, tracklist, tracks, data, activeTrackId;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _getState7 = getState(), playlist = _getState7.playlist, token = _getState7.token, tracklist = _getState7.tracklist;\n              tracks = tracklist;\n\n              if (!(href !== playlist.href)) {\n                _context2.next = 14;\n                break;\n              }\n\n              _context2.prev = 3;\n              _context2.next = 6;\n              return fetchWithToken(href, token);\n\n            case 6:\n              data = _context2.sent;\n              playlist = {\n                artists: data.artists,\n                date: data.release_date,\n                href,\n                imageUrl: data.images[0].url,\n                name: data.name\n              };\n              tracks = normalizeTracks(data.tracks.items, data.images);\n              _context2.next = 14;\n              break;\n\n            case 11:\n              _context2.prev = 11;\n              _context2.t0 = _context2[\"catch\"](3);\n              // tslint:disable-next-line\n              console.error('Error fetching Album:', _context2.t0);\n\n            case 14:\n              activeTrackId = skipUnavailableTracks(tracks, 0);\n              dispatch({\n                type: types.STOP_PLAY\n              });\n              dispatch({\n                activeTrackId,\n                playlist,\n                tracks,\n                type: types.ALBUM_UPDATE\n              });\n\n            case 17:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[3, 11]]);\n    }));\n\n    return function (_x3, _x4) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n};\nexport var clearPlaylistView = function clearPlaylistView() {\n  return function (dispatch, getState) {\n    dispatch({\n      type: types.CLEAR_PLAYLIST_VIEW\n    });\n  };\n};\nexport var startPlayFromTracklist = function startPlayFromTracklist() {\n  var track = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return function (dispatch, getState) {\n    var _getState8 = getState(),\n        tracklist = _getState8.tracklistView;\n\n    var trackId = skipUnavailableTracks(tracklist, track);\n    dispatch({\n      type: types.STOP_PLAY\n    });\n    setTimeout(function () {\n      dispatch({\n        trackId,\n        type: types.COPY_FROM_VIEW_AND_PLAY\n      });\n    }, 0);\n  };\n};","map":{"version":3,"sources":["C:/project/MusicAppMERN-master/MusicAppMERN-master/Music/src/actions/fetch-actions.js"],"names":["types","skipUnavailableTracks","setToken","token","type","TOKEN_SET","setGenres","genres","GENRES_SET","setCategoryPlaylist","categoryPlaylist","CATEGORY_PLAYLIST_SET","fetchWithToken","url","fetch","headers","Headers","Authorization","access_token","then","res","json","clearCategoryPlaylist","CATEGORY_PLAYLIST_CLEAR","fetchToken","dispatch","catch","err","console","log","fetchFeatured","getState","data","error","message","featured","playlists","items","sectionMessage","FEATURED_SET","fetchGenres","categories","fetchCategoryPlaylist","categoryId","setNewReleases","albums","NEW_RELEASES_SET","fetchNewReleases","normalizeTracks","trackArray","images","map","track","i","album","fetchPlaylistView","href","playlist","COPY_TO_VIEW","tracks","description","imageUrl","name","owner","display_name","SET_PLAYLIST_VIEW","startPlaylist","tracklist","STOP_PLAY","trackId","PLAYLIST_SET","startAlbum","artists","date","release_date","activeTrackId","ALBUM_UPDATE","clearPlaylistView","CLEAR_PLAYLIST_VIEW","startPlayFromTracklist","tracklistView","setTimeout","COPY_FROM_VIEW_AND_PLAY"],"mappings":"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","sourcesContent":["import * as types from '../actions/action-types';\nimport skipUnavailableTracks from '../utils/skipUnavailableTracks';\n\nconst setToken = token => ({\n  token,\n  type: types.TOKEN_SET,\n});\n\nconst setGenres = genres => ({\n  genres,\n  type: types.GENRES_SET,\n});\n\nconst setCategoryPlaylist = categoryPlaylist => ({\n  categoryPlaylist,\n  type: types.CATEGORY_PLAYLIST_SET,\n});\n\nconst fetchWithToken = (url, token) => {\n  return fetch(url, {\n    headers: new Headers({\n      Authorization: 'Bearer ' + token.access_token,\n    }),\n  }).then(res => res.json());\n};\n\nexport const clearCategoryPlaylist = () => ({\n  type: types.CATEGORY_PLAYLIST_CLEAR,\n});\n\nexport const fetchToken = () => dispatch => {\n  return (\n    fetch('https://ndj7ih3fo8.execute-api.eu-central-1.amazonaws.com/LATEST/')\n      .then(res => res.json())\n      .then(token => dispatch(setToken(token)))\n      // tslint:disable-next-line\n      .catch(err => console.log('Error fetching Token', err))\n  ); // TODO add error handling\n};\n\nexport const fetchFeatured = () => (dispatch, getState) => {\n  const { token } = getState();\n  const url = 'https://api.spotify.com/v1/browse/featured-playlists';\n\n  return (\n    fetchWithToken(url, token)\n      .then(data => {\n        if (data.error) {\n          throw data.error.message;\n        }\n        dispatch({\n          featured: data.playlists.items,\n          sectionMessage: data.message,\n          type: types.FEATURED_SET,\n        });\n      })\n      // tslint:disable-next-line\n      .catch(err => console.log('Error fetching Featured', err))\n  ); // TODO add error handling\n};\n\nexport const fetchGenres = () => (dispatch, getState) => {\n  const { token } = getState();\n  const url = 'https://api.spotify.com/v1/browse/categories?limit=50';\n\n  fetchWithToken(url, token)\n    .then(data => {\n      if (data.error) {\n        throw data.error.message;\n      }\n      dispatch(setGenres(data.categories.items));\n    })\n    // tslint:disable-next-line\n    .catch(err => console.error(err));\n};\n\nexport const fetchCategoryPlaylist = categoryId => (dispatch, getState) => {\n  const { token } = getState();\n  const url = `https://api.spotify.com/v1/browse/categories/${categoryId}/playlists?limit=50`;\n\n  fetchWithToken(url, token)\n    .then(data => {\n      if (data.error) {\n        throw data.error.message;\n      }\n      dispatch(setCategoryPlaylist(data.playlists.items));\n    })\n    // tslint:disable-next-line\n    .catch(err => console.error(err));\n};\n\nconst setNewReleases = albums => ({\n  albums,\n  type: types.NEW_RELEASES_SET,\n});\n\nexport const fetchNewReleases = () => (dispatch, getState) => {\n  const { token } = getState();\n  const url = 'https://api.spotify.com/v1/browse/new-releases?limit=50';\n\n  fetchWithToken(url, token).then(data =>\n    dispatch(setNewReleases(data.albums.items))\n  );\n};\n\nconst normalizeTracks = (trackArray, images) => {\n  return trackArray.map((track, i) => {\n    return { track: { ...track, album: { images: [...images] } } };\n  });\n};\n\nexport const fetchPlaylistView = href => (dispatch, getState) => {\n  const { token, playlist } = getState();\n\n  if (href === playlist.href) {\n    dispatch({\n      type: types.COPY_TO_VIEW,\n    });\n  } else {\n    fetchWithToken(href, token).then(data => {\n      const tracks =\n        data.type === 'album'\n          ? normalizeTracks(data.tracks.items, data.images)\n          : data.tracks.items;\n      dispatch({\n        playlist: {\n          description: data.description,\n          href,\n          imageUrl: data.images[0].url,\n          name: data.name,\n          owner: data.owner && data.owner.display_name,\n          type: data.type,\n        },\n        tracks,\n        type: types.SET_PLAYLIST_VIEW,\n      });\n    });\n  }\n};\n\n// Fetches playlist if not in memory and starts it from first available track\nexport const startPlaylist = ({ href }) => async (dispatch, getState) => {\n  let { playlist, tracklist: tracks, token } = getState();\n  dispatch({ type: types.STOP_PLAY });\n\n  if (href !== playlist.href) {\n    const data = await fetchWithToken(href, token);\n    if (data.error) {\n      throw data.error.message;\n    }\n    playlist = {\n      description: data.description,\n      href,\n      imageUrl: data.images[0].url,\n      name: data.name,\n      owner: data.owner.display_name,\n      type: data.type,\n    };\n    tracks = data.tracks.items;\n  }\n\n  const trackId = skipUnavailableTracks(tracks, 0);\n  dispatch({\n    playlist,\n    trackId,\n    tracks,\n    type: types.PLAYLIST_SET,\n  });\n};\n\n// Fetches album if not in memory and starts it from first available track\nexport const startAlbum = ({ href }) => async (dispatch, getState) => {\n  let { playlist, token, tracklist } = getState();\n  let tracks = tracklist;\n\n  if (href !== playlist.href) {\n    try {\n      const data = await fetchWithToken(href, token);\n      playlist = {\n        artists: data.artists,\n        date: data.release_date,\n        href,\n        imageUrl: data.images[0].url,\n        name: data.name,\n      };\n      tracks = normalizeTracks(data.tracks.items, data.images);\n    } catch (err) {\n      // tslint:disable-next-line\n      console.error('Error fetching Album:', err);\n    }\n  }\n\n  const activeTrackId = skipUnavailableTracks(tracks, 0);\n  dispatch({ type: types.STOP_PLAY });\n\n  dispatch({\n    activeTrackId,\n    playlist,\n    tracks,\n    type: types.ALBUM_UPDATE,\n  });\n};\n\nexport const clearPlaylistView = () => (dispatch, getState) => {\n  dispatch({\n    type: types.CLEAR_PLAYLIST_VIEW,\n  });\n};\n\nexport const startPlayFromTracklist = (track = 0) => {\n  return (dispatch, getState) => {\n    const { tracklistView: tracklist } = getState();\n    const trackId = skipUnavailableTracks(tracklist, track);\n\n    dispatch({ type: types.STOP_PLAY });\n\n    setTimeout(() => {\n      dispatch({\n        trackId,\n        type: types.COPY_FROM_VIEW_AND_PLAY,\n      });\n    }, 0);\n  };\n};\n"]},"metadata":{},"sourceType":"module"}